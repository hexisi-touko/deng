排序算法效率对比实验报告
1. 实验目的
对比 优化后的快速排序 与 堆排序 在不同数据规模下的运行效率，分析两种算法的时间复杂度与实际性能差异。
2. 实验环境
操作系统：Windows 10
Python 环境：Python 3.x（Anaconda）
硬件配置：Intel i5/i7 CPU，8GB RAM
测试工具：time 模块计时，matplotlib 绘图
3. 算法原理
3.1 优化后的快速排序
原理：选择数组中间元素作为基准值（pivot），将数组分为小于、等于、大于基准值的三部分，递归排序。
时间复杂度：
平均：O (n log n)
最坏：O (n²)（优化后概率极低）
空间复杂度：O (log n)（递归栈）
3.2 堆排序
原理：
将数组构建为大顶堆
反复取出堆顶元素（最大值），并调整堆
时间复杂度：O (n log n)（无论最好 / 最坏 / 平均）
空间复杂度：O (1)（原地排序）
4. 实验数据
数组规模 n	优化快排时间 (s)	堆排序时间 (s)
1000	0.001303	0.000421
5000	0.006398	0.002882
10000	0.014127	0.002146
20000	0.030403	0.005053
50000	0.085748	0.015901
100000	0.152340	0.031305
注：堆排序使用 Python 内置 heapq 模块（C 语言实现），快排为纯 Python 递归实现。
5. 实验结果分析
性能差距：
堆排序在所有数据规模下均优于快排
数据规模越大，差距越明显
在 n=100000 时，堆排序速度约为快排的 5 倍
原因分析：
heapq 是 C 语言实现，执行效率远高于纯 Python 代码
快排的递归调用和列表切片在 Python 中有额外开销
两者理论时间复杂度均为 O (n log n)，但常数因子差异大
公平性讨论：
若要公平对比算法本身，应都使用纯 Python 实现
内置模块的性能优势不代表算法本身更优
6. 结论
理论上两种算法时间复杂度相同，但实际性能受实现语言和细节影响很大
在 Python 中，使用内置 heapq 模块实现的堆排序性能优于纯 Python 实现的快排
对于大规模数据处理，选择底层优化实现的算法库可显著提升性能